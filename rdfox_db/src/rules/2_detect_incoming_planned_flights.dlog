@prefix fx: <http://www.fixm.aero/flight/4.3/>.
@prefix fb: <http://www.fixm.aero/base/4.3/>.
@prefix ax: <https://aware-sesar.eu/aixm/5.1.1/>.
@prefix : <https://aware-sesar.eu/>.

# TODO: MISSING coordination status
[?flight, :isAircraftAlreadyAssumed, ?aircraftAlreadyAssumedIndicator] :-
    [?flight, fx:coordinationStatus, ?coordStatus],
    [?coordStatus, fx:status, ?statusValue],
    BIND(
        IF(
            ?statusValue = "ASSUMED",
            1,
            0
        )
        AS ?aircraftAlreadyAssumedIndicator
    ).

# TODO: MISSING coordination status
[?flight, :isAircraftAlreadyTransferred, ?aircraftAlreadyTransferredIndicator] :-
    [?flight, fx:coordinationStatus, ?coordStatus],
    [?coordStatus, fx:status, ?statusValue],
    BIND(
        IF(
            ?statusValue = "TRANSFERRED",
            1,
            0
        )
        AS ?aircraftAlreadyTransferredIndicator
    ).

# This checks that the aircraft's current position is within the given sector's upper and lower limit.
[?flight, :withinSectorVertically, ?sector] :-  # [DONE]
    [?flight, :currentElement, ?currElement],
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, fx:level, ?currLevel],
    [?currLevel, fb:flightLevel, ?currFL],

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?sector, ax:lowerLimit, ?lowerLimit],
    [?lowerLimit, :limitValue, ?lowerLimitValue],
    [?lowerLimit, :limitUoM, ?lowerLimitUoM],
    [?sector, ax:upperLimit, ?upperLimit],
    [?upperLimit, :limitValue, ?upperLimitValue],
    [?upperLimit, :limitUoM, ?upperLimitUoM],

    BIND(
        IF(
            ?lowerLimitUoM = "VERTICAL_UOM_FEET",
            ?lowerLimitValue/100, # Convert to FL
            ?lowerLimitValue # Already in FL
        )
        AS ?lowerValue
    ),

    BIND(
        IF(
            ?upperLimitUoM = "VERTICAL_UOM_FEET",
            ?upperLimitValue/100, # Convert to FL
            ?upperLimitValue # Already in FL
        )
        AS ?upperValue
    ),

    FILTER(
        ?currFL <= ?upperValue &&
        ?currFL >= ?lowerValue
    ).

# This checks that the aircraft's current position is within the 3D sector - both horizontally and vertically.
[?flight, :withinSector, ?sector] :-    # [DONE]
    [?flight, :withinSectorHorizontally, ?sector],
    [?flight, :withinSectorVertically, ?sector].

# 5.2.1. Check that aircraft is close to Sector boundary
# TODO: MISSING speed
[?flight, :aircraftCloseToSectorBoundary, ?sector] :-
    [?flight, :isAircraftAlreadyAssumed, 0],
    [?flight, :isAircraftAlreadyTransferred, 0],
    NOT [?flight, :withinSector, ?sector],
    [?flight, :currentElement, ?currElement],
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, fx:level, ?currLevel],
    [?currLevel, fb:flightLevel, ?currFL],
    [?currPoint4D, fx:predictedAirspeed, ?currSpeed],
    [?flight, :distanceToClosestHorizontalBoundary, ?minDist], # Horizontal distance to 2D sector

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?sector, ax:lowerLimit, ?lowerLimit],
    [?lowerLimit, :limitValue, ?lowerLimitValue],
    [?lowerLimit, :limitUoM, ?lowerLimitUoM],
    [?sector, ax:upperLimit, ?upperLimit],
    [?upperLimit, :limitValue, ?upperLimitValue],
    [?upperLimit, :limitUoM, ?upperLimitUoM],

    BIND(
        IF(
            ?lowerLimitUoM = "VERTICAL_UOM_FEET",
            ?lowerLimitValue/100, # Convert to FL
            ?lowerLimitValue # Already in FL
        )
        AS ?lowerValue
    ),

    BIND(
        IF(
            ?upperLimitUoM = "VERTICAL_UOM_FEET",
            ?upperLimitValue/100, # Convert to FL
            ?upperLimitValue # Already in FL
        )
        AS ?upperValue
    ),

    BIND (
        ?minDist/(?currSpeed*0.514444444) # Speed in knots, converted to m/s - time is in seconds
        AS ?timeToReachSector
    ),
    BIND(
        MINFN(
            ABS(?upperValue - ?currFL), ABS(?lowerValue - ?currFL)
        )
        AS ?verticalDistanceToSector
    ),
    FILTER(
        # 5 minutes away
        ?timeToReachSector <= 5*60 ||
        ?verticalDistanceToSector <= 1000
    ).

# When the aircraft is planned:
[?flight, :plannedAircraftCloseToSectorBoundary, ?sector] :-
    [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :aircraftCloseToSectorBoundary, ?sector].

# When the aircraft is not planned:
[?flight, :notPlannedAircraftCloseToSectorBoundary, ?sector] :-
    NOT [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :aircraftCloseToSectorBoundary, ?sector].

# TODO: Check if this rule is needed - similar to 5.2.3 last rule
[?flight, :aircraftNotCloseToSectorBoundary, ?sector] :-
    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?flight, :currentElement, ?currElement], # Some dummy binding to make the rule valid (using NOT needs positive case)
    NOT [?flight, :plannedAircraftCloseToSectorBoundary, ?sector],
    NOT [?flight, :notPlannedAircraftCloseToSectorBoundary, ?sector].


# 5.2.2. Check that aircraft is approaching Sector boundary
[?flight2, :aircraftApproachingToSectorBoundary, ?sector] :-
    # Identify consecutive timestamps
    [?prevT, :next, ?currT],  
    # Bind flights at each timestamp
    [?prevT, fx:flight, ?flight1],
    [?currT, fx:flight, ?flight2],
    # Extract the same FlightIdentification for both flights
    [?flight1, fx:flightIdentification, ?ident1],
    [?flight2, fx:flightIdentification, ?ident2],
    [?ident1, fb:aircraftIdentification, ?flightID],
    [?ident2, fb:aircraftIdentification, ?flightID],

    # Extract previous and current elements for the flight at each timestamp
    [?flight1, :currentElement, ?prevElement],
    [?flight2, :currentElement, ?currElement],

    [?flight2, :isAircraftAlreadyAssumed, 0],
    [?flight2, :isAircraftAlreadyTransferred, 0],
    NOT [?flight2, :withinSector, ?sector],
    
    # Extract previous and current positions and flight levels
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, fx:position, ?currPosition],
    [?currPosition, fb:pos, ?currPoint],
    [?currPoint, fb:lat, ?currLat],
    [?currPoint, fb:lon, ?currLon],
    [?currPoint4D, fx:level, ?currLevel],
    [?currLevel, fb:flightLevel, ?currFL],
    [?flight2, :distanceToClosestHorizontalBoundary, ?currMinDist], # Horizontal distance to sector

    [?prevElement, fx:point4D, ?prevPoint4D],
    [?prevPoint4D, fx:position, ?prevPosition],
    [?prevPosition, fb:pos, ?prevPoint],
    [?prevPoint, fb:lat, ?prevLat],
    [?prevPoint, fb:lon, ?prevLon],
    [?prevPoint4D, fx:level, ?prevLevel],
    [?prevLevel, fb:flightLevel, ?prevFL],
    [?flight1, :distanceToClosestHorizontalBoundary, ?prevMinDist], # Horizontal distance to sector

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?sector, ax:lowerLimit, ?lowerLimit],
    [?lowerLimit, :limitValue, ?lowerLimitValue],
    [?lowerLimit, :limitUoM, ?lowerLimitUoM],
    [?sector, ax:upperLimit, ?upperLimit],
    [?upperLimit, :limitValue, ?upperLimitValue],
    [?upperLimit, :limitUoM, ?upperLimitUoM],

    BIND(
        IF(
            ?lowerLimitUoM = "VERTICAL_UOM_FEET",
            ?lowerLimitValue/100, # Convert to FL
            ?lowerLimitValue # Already in FL
        )
        AS ?lowerValue
    ),

    BIND(
        IF(
            ?upperLimitUoM = "VERTICAL_UOM_FEET",
            ?upperLimitValue/100, # Convert to FL
            ?upperLimitValue # Already in FL
        )
        AS ?upperValue
    ),

    BIND(
        MINFN(
            ABS(?upperValue - ?currFL), 
            ABS(?lowerValue - ?currFL)
        )
        AS ?currVerticalDistanceToSector
    ),

    BIND(
        MINFN(
            ABS(?upperValue - ?prevFL), 
            ABS(?lowerValue - ?prevFL)
        )
        AS ?prevVerticalDistanceToSector
    ),

    FILTER(
        ?currMinDist < ?prevMinDist ||
        ?currVerticalDistanceToSector < ?prevVerticalDistanceToSector
    ).

# When the aircraft is planned:
[?flight, :plannedAircraftApproachingToSectorBoundary, ?sector] :-
    [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :aircraftApproachingToSectorBoundary, ?sector].

# When the aircraft is not planned:
[?flight, :notPlannedAircraftApproachingToSectorBoundary, ?sector] :-
    NOT [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :aircraftApproachingToSectorBoundary, ?sector].

# TODO: Check if this rule is needed - similar to 5.2.3 last rule
[?flight, :aircraftNotApproachingToSectorBoundary, ?sector] :-
    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?flight, :currentElement, ?currElement], # Some dummy binding to make the rule valid (using NOT needs positive case)
    NOT [?flight, :plannedAircraftApproachingToSectorBoundary, ?sector],
    NOT [?flight, :notPlannedAircraftApproachingToSectorBoundary, ?sector].


# 5.2.3. Check that aircraft’s altitude is within the altitude band of the Sector
# When the aircraft is planned:
[?flight, :plannedAircraftAltitudeWithinSectorBandAltitude, ?sector] :-     # [DONE]
    [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :withinSectorVertically, ?sector].

# When the aircraft is not planned:
[?flight, :notPlannedAircraftAltitudeWithinSectorBandAltitude, ?sector] :-    # [DONE]
    NOT [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :withinSectorVertically, ?sector].

# Does this rule mean that the aircraft is not within the altitude band of the sector? 
# If so, we alredy have this rule, why using "planned" in this context?
# [?flight, :aircraftAltitudeNotWithinSectorBandAltitude, ?sector] :-
#     [?aixmFeatures, :contains, ?airspace],
#     [?airspace, ax:geometryComponent, ?sector], # Dummy binding to make the rule valid (using "NOT" needs positive case)
#     [?flight, :currentElement, ?currElement], # Dummy binding to make the rule valid (using "NOT" needs positive case)
#     NOT [?flight, :plannedAircraftAltitudeWithinSectorBandAltitude, ?sector],
#     NOT [?flight, :notPlannedAircraftAltitudeWithinSectorBandAltitude, ?sector].


# 5.2.4. Check that aircraft’s altitude is approaching the Sector altitude
[?flight2, :approachingSectorAltitude, ?sector] :-  # [DONE]
    # Identify consecutive timestamps
    [?prevT, :next, ?currT],  
    # Bind flights at each timestamp
    [?prevT, fx:flight, ?flight1],
    [?currT, fx:flight, ?flight2],
    # Extract the same FlightIdentification for both flights
    [?flight1, fx:flightIdentification, ?ident1],
    [?flight2, fx:flightIdentification, ?ident2],
    [?ident1, fb:aircraftIdentification, ?flightID],
    [?ident2, fb:aircraftIdentification, ?flightID],

    # Extract previous and current elements for the flight at each timestamp
    [?flight1, :currentElement, ?prevElement],
    [?flight2, :currentElement, ?currElement],
   
    # Extract previous and current positions and flight levels
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, fx:level, ?currLevel],
    [?currLevel, fb:flightLevel, ?currFL],

    [?prevElement, fx:point4D, ?prevPoint4D],
    [?prevPoint4D, fx:level, ?prevLevel],
    [?prevLevel, fb:flightLevel, ?prevFL],

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?sector, ax:lowerLimit, ?lowerLimit],
    [?lowerLimit, :limitValue, ?lowerLimitValue],
    [?lowerLimit, :limitUoM, ?lowerLimitUoM],
    [?sector, ax:upperLimit, ?upperLimit],
    [?upperLimit, :limitValue, ?upperLimitValue],
    [?upperLimit, :limitUoM, ?upperLimitUoM],

    BIND(
        IF(
            ?lowerLimitUoM = "VERTICAL_UOM_FEET",
            ?lowerLimitValue/100, # Convert to FL
            ?lowerLimitValue # Already in FL
        )
        AS ?lowerValue
    ),

    BIND(
        IF(
            ?upperLimitUoM = "VERTICAL_UOM_FEET",
            ?upperLimitValue/100, # Convert to FL
            ?upperLimitValue # Already in FL
        )
        AS ?upperValue
    ),

    FILTER(
        # 1. case: A/C is approaching the lower limit from below the sector
        (?prevFL < ?currFL && ?prevFL < ?lowerValue && ?currFL < ?lowerValue) ||
        # 2. case: A/C is approaching the upper limit from above the sector
        (?prevFL > ?currFL && ?prevFL > ?upperValue && ?currFL > ?upperValue) ||
        # 3. case: A/C is approaching the lower limit from within the sector
        (?prevFL > ?currFL && ?prevFL > ?lowerValue && ?prevFL <= ?upperValue && ?currFL > ?lowerValue && ?currFL <= ?upperValue) ||
        # 4. case: A/C is approaching the upper limit from within the sector
        (?prevFL < ?currFL && ?prevFL < ?upperValue && ?prevFL >= ?lowerValue && ?currFL < ?upperValue && ?currFL >= ?lowerValue)
    ).

[?flight, :aircraftWithinSectorVerticallyNotApproachingSectorAltitude, ?sector] :-  # [DONE]
    [?flight, :currentElement, ?currElement],
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, :verticalRate, "0"^^xsd:decimal],

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    [?flight, :withinSectorVertically, ?sector].

[?flight, :aircraftOutsideSectorVerticallyNotApproachingSectorAltitude, ?sector] :-  # [DONE]
    [?flight, :isAircraftAlreadyAssumed, 0],
    [?flight, :isAircraftAlreadyTransferred, 0],
    [?flight, :currentElement, ?currElement],
    [?currElement, fx:point4D, ?currPoint4D],
    [?currPoint4D, :verticalRate, "0"^^xsd:decimal],

    [?aixmFeatures, :contains, ?airspace],
    [?airspace, ax:geometryComponent, ?sector],
    NOT [?flight, :withinSectorVertically, ?sector].

[?flight, :plannedAircraftIsApproachingSectorAltitude, ?sector] :-   # [DONE]
    [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :approachingSectorAltitude, ?sector].

[?flight, :notPlannedAircraftIsApproachingSectorAltitude, ?sector] :-   # [DONE]
    NOT [?flight, :aircraftIsPlanned, ?sector],
    [?flight, :approachingSectorAltitude, ?sector].